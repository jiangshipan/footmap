package com.jsp.footmap.model;/** * 存放Record的阻塞队列 * @param <T> */public class ArrayQueue<T> {    /**     * 队列内任务数量     */    private int count = 0;    /**     * 最终的数据存储     */    private Object[] items;    /**     * 队列满时的阻塞锁     */    private Object full = new Object();    /**     * 队列为空时的阻塞锁     */    private Object empty = new Object();    /**     * 获取数据时的下表     */    private int getIndex;    /**     * 写入数据时的下标     */    private int putIndex;    public  ArrayQueue(int size) {        items = new Object[size];    }    /**     * 从队尾写入数据     *     * 写入队列满时会阻塞， 直到获取线程消费了队列数据后唤醒写入线程     * @param t     */    public void put(T t) {        synchronized (full) {            while (count == items.length) {                try {                    full.wait();                } catch (InterruptedException e) {                    break;                }            }        }        synchronized (empty) {            //写入            items[putIndex] = t;            count ++;            putIndex++;            if (putIndex == items.length) {                //超过数组长度后需要从头开始                putIndex = 0;            }            empty.notify();            //System.out.println("唤醒一个消费者:" + "count = " + count);        }    }    public T get() {        synchronized (empty) {            //System.out.println(count);            while( count == 0) {                try {                    empty.wait();                } catch (InterruptedException e) {                    return null;                }            }        }        synchronized (full) {            Object result = items[getIndex];            items[getIndex] = null;            count--;            getIndex++;            if (getIndex == items.length) {                getIndex = 0;            }            return (T)result;        }    }    public synchronized  int size() {        return this.count;    }    public boolean isEmpty() {        if (count == 0) {            return true;        }        return false;    }    /**     * 清除所有任务     */    public void clearAll() {        for (int i = 0; i < putIndex; i++) {            items[i] = null;        }        count = 0;        putIndex = 0;        getIndex = 0;    }}